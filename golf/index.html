<meta charset=utf-8><title>Super Chrono Portal Maker</title><body bgcolor=0><center><canvas width=1280 height=648 style="border:1px Q;background:#5C94FC;cursor:crosshair"id=a>
<img src="data:;base64,iVBORw0KGgoAAAANSUhEUgAAA1QAAAAQCAMAAAAmns6IAAAAWlBMVEUAAADFycoAAADjnSWAgID///+xNCVHSUECRYe6YRHJu5wAqADITAz8vLBIAP//slkCa9Mpzv+A0BDEUU9qawSKjsBCQv+wtOb3ORD/AABhY1rIzP4BIkP/2bLDllwqAAAAAnRSTlMAOrCfFIoAAAY2SURBVHhe1duJkqQ2DAZg5Qf6mPveI8n7v2Yk2SCQxjbQM53kT6eNQHZtde1XZpheWhdwUnF3bwG/+mGR/m8XiqFf8/F5EaLzIkTvi5AGGjsGHY80nUtjruDy6IJGCC+c29sXHfiV86KB+/O0czo9Sf5Kw+lEKdXZ5xS6OF1HBIBovhxyxoJmB4C/muOKbcvEMxRmxjntdWINxAabbUfhRLXffQC+KOSksRq3nNR9f2fB/R2Ghaoe5zOyh3REkkcJIio1NZ///HF+XATvfy4iqkYZCc0N53j8/ft4lCPRJLiR3imZsOCnC16qWYMKSKeA70F1HlNCVr9sDROqsXRQahpQQYUty2jgz4SZkcO6dSy16wGVo13tb30aBVPQnMyUBp+imqvq8SmqEcho6ddsZFPPU4aBUQkZnqgzBJWw+vHjh5ISVEpqGLJTKCmJsoKaAjBoQBAJ2YKimrymI8yI3MasQKWkhkG7C47G7EfVcQIyX4fSNxyYUQek5fSdYEFVAyqosGkZq+2Mnxk7aOU6ltqEIirtq/a39m2g+ZegjWrop6CECktUQxp7RfU8i6CSyGTbqRRVOnhXU4pKAkalpDKrhEpdFVCpJTWVjmBkzIypaaPKpkxVNIWc0+mPXagUATqHLNShDA2Hg6A6nM/g9dhYRkWcogaKV+PN0MZlDIoTSlTsoPY6oUPjUaahjAomPPRbUfo0iqiecr4IlZoyVYxJUYFHh2pYhWqIqI4cQ6UpoVJL6f3n16Aa1JSqQsGUqdqFqkuJyGJtZVR5yKgOnUbGhROnoVjG1q3L6OC5glPuoNXraIqoYrMF83zaH7X64ut3qpiIilBCNaxApaYUlQZImDh6AAyLwMc8yfvFqNQUh0lpEEy57EBF+W4tIPN1KH2DoIKgOnO4cn8xL9up6IJlbBMo6129TpRYs24xNfANbjvduVOd9C0+qCAA9Z1KAturIiowqkFt8ThHNexBRWzp+Pp6c/P6KkekqKAv26r4lSCA7M5Pj/4XqKjTRGRwtSv9hENCRbxDAUzM/dSw4UEFuWsRlcW11jA0UbXXsdA+VPYW+81U9dNoo3L+5En6hArYg4obGRVkVFRm6nkNKomh0v3pVaOHc1QooMqm9OhyVJwaqqdFdqE6HB705ZEBEV0srWFcgdfi4iFV2PpIPaKi9aioiopWo6ImKnfBzS+iKhDdgIraqIYU7c23f0kVAAG2H1U/ojJTK1FpqqjALxkjqp8uqGcdqkHzXagOI6qDnZEagDVM5rqDlmO7qVRFGqmsXPUsnOgKOxVnJSpqo8J3ocIX7FQR1Z2gElEyXI7KTBmqR8BQKaZ3QxVv/27E1I3d/mk+RxXSMNVGNaoq7VSnWTaiMkGqxNxIAHRmquNX3pPAdSf9+bJGVRG9Ef/P13TOm2NQv0H69p+pNC1UZGnh/C5U+IKfqSKqe3D4gLP9QQWSJh50ZFRmar5TPbqdioeAapgeVLApPcBGVE00m27/BkG1NOkRtVHBgsQEGrlno3RCUQCdqVt2i0Ft1+6ESpJRsSo1xYVlNypaj4quhor2PqhoUa9tlJp1qCigkq8qlVC5J+pxp8qYdFBUZmrP7V/lkbqaugoqizuB7ajwOAvy3qOoOlWiKDSUw0JSi5m06zqd8lbGjnS+Fv8mKutGu6OGyrquhMpUXYaKHCrNalSmClRApabWovKJv/y13/5eA1UjW1HBRVQASdGI6iGFTJW2jNWDTuMGRYMOkEKTUVnhfhVj5TZUxXmxtC47WtERUcWua6AyVReioiqqHlP6Aqpw99fLoGFQM1OMKgMEpq8p2c9UXGBYBPFrSuk0hiuhGhaBqz0ql4jKzyeiBCYrUhNakoUZkRDJ5hJRRaMQZIb1S6fWCZWFYhlR5QRUFmqjIrj+ZkdEFbv2oMrZgooAP30XKiqhAsSUpY+oJGaKsiX0OSLJ8tH4Qm1EZV+ohX2hdgzov4fqaf7fKlTJy6RGBqum4k27xtFakinyiVB8uQWVm1dFFXm2O6KPyPxqqGgXqilcFG5P7saxxyKujGp7F/pYhODy7gKXwj/9SKEroKpnOyoXY2JaQvXGCVcc15YqX25C5ea1UZET0+qIqHzXFVFRA9U/0X8GNpca52UAAAAASUVORK5CYII"hidden id=b>
<script>

// Globals
// =======
  
// Canvas context 2D
c = a.getContext("2d");

// Init local storage to 1 if it's not already set
localStorage["scpm"] = localStorage["scpm"] || 1;

// Current screen (0: main menu / 1: level selection / 2: playing / 3: editor)
d = 0;

// Previous screen (when we quit a level, 0: when playing a G level / 1: when playing a built-in level / 3: whe testing a level in the level eitor)
n = 0;

// Mouse down (player is clicking)
o = false;

// Player is right clicking
p = false;

// Mouse coords (in px)
x = y = 0;

// Current level
s = 0;

// keys state
aa = ab = ac = 0;

// Chrono
_ = 0;

// loop
ad = 0;

// All the data of the current level
t = {};

// Built-in levels:
levels = [

// 0
,
  
// 1
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000200\
0000065656000000000000000060000600000000\
0000000000000000400400000000000000000000\
0F00000000000004400440000000000000000000\
0G00000000000044400444000070000700000400\
3333333333333333300333333333333333333333\
3333333333333333300333333333333333333333",I:[[]],J:[],txt:"Move with arrow keys or WASD or ZQSD. Collect all coins and reach the flag.",ac:210},

// 2
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000060060060000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000060060000000000000000000020\
0000000050050050050000400040000000000000\
0F00000000000000000004400044000000000000\
0G00000000000000000044400044400077000000\
3333333333333333333333333333333333333333\
3333333333333333333333333333333333333333",I:[],J:[],txt:"If you're stuck, restart with R.",ac:376},

// 3
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000060000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000040040040080080000020\
0000060060060000400000000000000000000000\
0F00000000000004440000000000000000000000\
0G00000000000044444000000000000000000000\
3338888888888888888888888888888888888333\
3338888888888888888888888888888888888333",I:[],J:[],txt:"Ice is slippy if you're not standing still on it.",ac:254},

// 4
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000600000000000000000000000000000\
0000000000000000000000000000000000000020\
0000000000600000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000600000<00000000000000000000000\
0000000000000000000000004000000004000000\
0000<00<00400000000000044000000004400000\
0F00000000440000000000444000000004440000\
0G00000000444000000004444000000004444000\
3333333333333333033333333333333333333333\
3333333333333333333333333333333333333333",I:[],J:[],txt:"Press space to hold and drop cubes. Jump and press space to throw them.",ac:400},

// 5
{hash:"0000000000000000000000000000000000000000\
00000000<0000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000999900000000000000000000000000000\
0000000000900000000000000000000000000000\
0000000:::900000000000000000000000000000\
0000000000900000000000000000000000000000\
0000000999900000000000000000000000000000\
0000000000900000000000000000000000000000\
0000000:::900000000000000000000000000000\
0000000000900000000000000000000000000000\
0000000666900000000000000000000000000002\
0000000000900000<00000000000000000000000\
0000000999900000500000000000000000000004\
0000000000900000000000000000000000000004\
0F00000000900000000000000000000000000004\
0G0;000000900;000000;00000000000;0000004\
33333333333333333999999933333::::::33333\
33333333333333333999999933333::::::33333",I:[],J:[],txt:"Yellow switches are all connected.",ac:1000},

// 6
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000033333333333000\
0000000044000000000000000000000000000000\
0000000000000000000060000000000000000000\
000000000000600000000000000<000000200000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000300000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0F00000000000000000000000000000000000000\
0G00000000000000000000000000000000000000\
3333333333333333333333333333333333333333\
3333333333333333333333333333333333333333",I:[[8,8,16,6,16],[24,16,6,22,16],[35,7,16,30,5]],J:[],txt:"Each green switch controls one pipe.",ac:677},

// 7
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000<00000000000\
0000000000000000000000000000000000000000\
0000000000000000000009999999990000000000\
0000000000000000000000000000000000000020\
0000000000000000000000000000000000000000\
00F0000000000000000000000000000000000000\
00G0000000000000000000000000000000000000\
3333330000000000000000000000000000000000\
3333330000000000000000000000000000000000\
0000000000000000000000000000000000000040\
000000000000000000;000060000000000000040\
0000000000000000333330060000000000000040\
0000000000000000333330060000000033333333\
0000000000000000000000000000000033333333\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000",I:[],J:[[8,9,13,17],[28,6,23,14]],txt:"Platforms will only move if they have more weight on one side",ac:261},

// 8
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0444444444444400000000000000000000000000\
0300000000000000000000000000000000000040\
0306060606000000000000000000000000006040\
03000000000<0000000000000000000000000040\
0300000000000000000000000000000000000040\
0300000444444400000000000000000000000040\
0300000300000000000000000000000000000040\
0300000300000000000000000000000000000040\
0300000300000000000000000000000000000040\
0300000300000000000000000000000000000040\
0300000300000000000000000020000000000040\
0300000300000000000000000000000000000040\
0400F00400000000000000000000000000000040\
0400G0040000000000000000000000000000;040\
044444440000000000000000003::::::::33330\
0000000000000000000000000000000000000000",I:[],J:[],txt:"Aim with mouse, send portals with left click and right click.",ac:284},

// 9
{hash:"0000000000000000000000000000000000000000\
0444400000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000006000000000000000000000000000\
0400000000000000000000000000000000000000\
0400000000000000000000000000000000000200\
0400000000000000000000000000000000000000\
040000F000000000000000000000000000000000\
040000G000000000000000000000000000000000\
0444444444444000000000000888888888888880\
0000000000000000000000000000000000000000",I:[],J:[],txt:"Use Momentum!",ac:183},

// 10
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000008888888888888888888800000000000\
0000000003000000000000000000800000000000\
0000000003000000000000000000800000000000\
0000000003002000000000000000800000000000\
0000000003000000000000000000800000000000\
0000000003000000000006000000800000000000\
0000000003000007700000000000800000000000\
0000000004444444444444060000800000000000\
0000000003000000000000000000800000000000\
0000000003000000000006000000800000000000\
0000000003000000000000000000800000000000\
0000000003000000000000000000800000000000\
000000000300F000000000000000800000000000\
000000000300G000000000000000800000000000\
0000000004444444444444000000800000000000\
0000000000000000000000000000000000000000",I:[],J:[],txt:"Portals bounce on ice!",ac:162},

// 11
{hash:"0000000000000000000000000000000000000000\
0888888888888888888888888888888888888880\
0800000000000000000000000000000000000080\
0800000000000000000000000000000000000080\
08998000000000000000000000000000008:::80\
08998000000000000000000000000000008:::80\
08998000000000000000000000000000008:::80\
0800800000000000000000000000000000800080\
0800800000000000000000000000000000800080\
0800800000000000000000000000000000800080\
0800800000004333333333330000000000800080\
0800800000044300000300000006666660800080\
0800800000444300000300000000000000800080\
0800833333333300000300200033333333800080\
0800800000000000000400000000000000000080\
080000000000000F000400000000000000000080\
080000000000000G0;0400000000000000000080\
0800000000000033333333330000000000000080\
0000000000000000000000000000000000000000",I:[],J:[],ac:528},

// 12
{hash:
"0000000000000000004400000000000000000000\
0000000000000000000000000000000000000000\
000000000000000002F000000000000000000000\
000000000000000000G000000000000000000000\
0000000000000000033000000000000000000000\
0000000000000000000000000000000000000000\
0000000000006000000000006000000000000000\
0000000000000000000000000000000000000000\
0000000000060000000000000060000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000006000000000000000\
0000000000006000000000000000000000000000\
0000000000000000000000000000000000000000\
00000000000000000<6000000000000000000000\
0000000000000000033000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000044000000000000000000",I:[],J:[[],[19,7,24,4],[19,9,24,15],[19,11,14,15],[19,13,14,4]],ac:446},

// 13
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000002030000000\
0000000000000000000000000000000030000000\
0000000000000000000000000000000030000000\
0000000000000000000000033333333330000000\
0000000000000000000000030000000000000000\
0000000000000000000000030000000000000000\
0000000000000000000000030000000000000000\
0000000000000000000000030000000000000000\
0000000000000000000000030000000000000000\
0000000030600000000000030000000000000000\
0000000030000000F00000030000000000000000\
0000000030000000G00000030000000000000000\
0000000033333333333333330000000000000000\
0000000000000000000000000000000000000000",I:[[21,16,8,10,16]],J:[],txt:"Need a little help from the past? Go to the time machine and press Shift!",ac:240},

// 14
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000020000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000006660000000\
0000000000000000000000000000000000000000\
0000000000000000000060000000000000000000\
0000000000000000000000000333009990000000\
000000000000000000600::00000000000000000\
00000000000000000000:::00000000000000000\
0000000000000000600::::00000000000000000\
000000000000000000:::::00000000000000000\
00000000000000600::::::00000000000000000\
0000000000000000:::::::00000000000000000\
000000000000600::::::::00000000000000000\
00000000000000:::::::::00000000000000000\
00000F0000600::::::::::00000000000000000\
00000G00;000:::::::::::00000000000000000\
3333333333333333333333333333333333333333\
3333333333333333333333333333333333333333",I:[],J:[],ac:309},

// 15
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000200000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000003000000000000\
0000000000000000000000000003000000000000\
0000000000000000000000003333000000000000\
0000000000000000000000003000000000000000\
0000000000000000000000003000000000000000\
0000000000000000000000003000000000000000\
0000000000000000000000003000000000000000\
0000000000030F00000000003000000000000000\
0000000000030G00000<00003000000000000000\
0000000000033333333333333000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000",I:[],J:[],ac:162},

// 16
{hash:"00000000000000000000000<0000000000000000\
0000000000000200000000000000000000000000\
00000000000000000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000004000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000000000000000<0000F00000000000\
0000000000000000000000000000G00000000000\
00000000000000000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000000000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000000000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000000000000000<0000000000000000\
0000000000000000000000000000000000000000\
00000000000000000000000<0000000000000000\
0000000003333333333333333333333300000000\
0000000000000000000000000000000000000000",I:[],J:[],ac:360},

// 17
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000003000000000000000000003000000000\
0000000003000000606060606060603000000000\
0000000003000000000000000000003000000000\
00000000030999::::::::::::::::3000000000\
0000000003000000000000000000003000000000\
0000000003000000000000000000003000000000\
0000000003000000000000000000003000000000\
0000000003000000000000000000203000000000\
0000000003000000000000000000003000000000\
0000000003000000000000000000003000000000\
0000000003000000000000000000003000000000\
00000000030000000000000000F0003000000000\
0000000003000000;000000000G0003000000000\
0000000003333333333333333333333000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000",I:[[11,15,7,21,15]],J:[],txt:"Sometimes you need to make multiple time travels...",ac:674},

// 18
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000006000000\
0000000000000000000000000000000006000000\
0000000000000000000000000000000006000000\
000000000000000000000000000;;;;;;;000000\
0000000000000000000000000003333333000000\
0000002000000000000000000003000000000000\
0000000000000000000000000003000000000000\
0000030000000000000000000003000000000000\
00000300F0000000000000000003000000000000\
00000300G0000000000000000003000000000000\
0000033333399999999999933333000000000000\
0000000000300000000000030000000000000000\
0000000000300000000000030000000000000000\
0000000000300000000000030000000000000000\
0000000000333333333333330000000000000000\
0000000000000000000000000000000000000000",I:[[25,12,7,17,12]],J:[],txt:"If a past self dies or can't reach the time machine, it's a paradox! *wink the theme*",txt2:"But you win if a past self reaches the flag!",ac:651},

// 19
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000203000000000000\
0000000000000000000000000003000000000000\
0000000000000000000000003333000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000030F00000000000000000000000000000\
0000000030G000<00<00<0000000000000000000\
0000000033333333333333330000000000000000\
0000000000000000000000000000000000000000",I:[],J:[],ac:523},

// 20
{hash:"0000000000000000000000000000000000000000\
0000000000000000000<00000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000200000000000000\
000000000F000000000000000000000000000000\
000000000G000000000000000000000000000000\
0000000333330000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000<00033330000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
000000000000000000<0<0000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000333333000000000000000000\
0000000000000000000000000000000000000000",I:[],J:[[14,4,19,16]],txt:"Heros and cubes have the same R.",ac:335},

// 21
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000003444300000344430000000009000000000\
0000003000300000300030000000009000000000\
0000000000300000000000000000009000000000\
0000000000300000000000000000009000000000\
0000000000300;00000000000000009000000000\
0033300000333330000000000000009000000000\
0000000000000000000000000000009000000000\
0000000000000000000000000000009000000000\
0000000000000000000000000000009000000000\
0000000000000000000000000000009000000000\
0000000000000000000000000000009020000000\
0000000000000000000000000000009000000000\
00F0000000000000000000000000009000000000\
00G0000000000000000000000000009000000000\
0444444444444444444444444444444444400000\
0000000000000000000000000000000000000000",I:[[24,3,16,3,7]],J:[[8,12,18,12]],txt:"Only two portals can exist at the same time.",ac:946},

// 22
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000=00000000000000000000\
0000000006060606060=00000000000000000000\
0000000000000000000=00000000000000000000\
0000000000033333333333330000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000200000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000400000000000000000000000000\
000000000000444000000F000000000000000000\
000000300004444400000G000000003000000000\
0000003333333333333333333333333000000000\
0000000000000000000000000000000000000000",I:[[24,16,6,19,16]],J:[[]],txt:"Clouds will block all your future selves!",ac:457},

// 23
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000006000000000000002000\
000F000000000000000060600000000000000000\
000G00;000000000000000000000000000000000\
003333339990:::09990:::09990:::333333300\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000",I:[],J:[],txt:"Count in your head: 1-2-3-switch! 1-2-3-switch! I know, this one's terrible.",ac:356},

// 24
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000200000\
0000000000000000000000033333333300000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
000000000000000000<000000000000000000000\
0000000000000000099900000000000000000000\
0000000000000000000000000000000000000000\
0000000000000=00000000000000000000000000\
0000000000000=00000000030000000000000000\
00000003000F0=00000000030000000000000000\
00000003300G0=00000000030000000000000000\
0300000333333333333333330000000003330000\
0330;00000000000000000000000000000000000\
0333333000000000000000000333000000000000\
0000000000000000000000000000000000000000",I:[[21,14,5,26,16]],J:[],txt:"You can grab and throw cubes even if they're not here yet...",ac:558},

// 25
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000044440000000000000000\
0000000000000000000040000000000000000000\
0000000000000000000040000000000000000000\
0000000000000000000040000000000000000000\
0000000000000000000040000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000200\
000000009=000000000000000000000000000000\
000000009=000006000000040000000000000000\
00000F009=000000000000040000000000000000\
00000G009=000007000000040000000000000000\
0000333333333333333344440000000000000000\
0000300000000000000000000000000000000000\
00;0300000000000000000000000000000008880\
0333300000000000000000000000000000000000\
0000000000000000000000000000000000000000",I:[],J:[],txt:"You can aim and shoot ag even if you're not here yet...",ac:443},

// 26
{hash:"000F000000000000000000000000000000000000\
000G000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000700700000000707000000000000000000000\
0040404440<00400444000000000000000000000\
0047404000400400404000000000000000000000\
0044404400400400404000000000000000000000\
0040404000470470404000000000000000000000\
0040404440440440444000000000000000000000\
0000000000000000000000000000000000020000\
0000000000000000000666066006006606000000\
0000000000000000000888088068008808000000\
0000000000000000000080080088000808000000\
00===========000006080088008008808680000\
0000000000000000008080008008000808800000\
0000000000000000008880088088808808080000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000",I:[],J:[[33,5,24,5],[27,5,30,5]],ac:417},

// 27
{hash:"00000000000000000=0000000000000000000000\
00000000000000000=0F00003000000000000000\
00003333333330000=0G0;003000000000000000\
0000300000009000033333333000000000000000\
0000300000009000030000000000000000000000\
0000300000009000330000000000000000000000\
0000300033333333330000000000000000000000\
0000300000000000333333333333333333333330\
0000300000000000300000000090000000000030\
0000300000000000302000000090000000000030\
0333333333333300300000000090000000000030\
030000000:000000300000000070000000000030\
030000000:000000333444444444444444400030\
030000000:000000300000000000000000000030\
0300333333333333300600000000000000000030\
0300000000000000000000000000000000000030\
03000000000000000000004000000040<0000030\
0338888888888888888334400000004433333330\
0000000000000000000000000000000000000000",I:[[36,16,8,34,16]],J:[],ac:1777},

// 28
{hash:"0000000000000000000000000000000000000000\
0000000000000000000000000000000000000000\
00000000000000=0000000009000000000000000\
00000000000000=0020F00099000000000000000\
00000000000000=0000G00999000:00000000000\
0000000000000055555555555000000000000000\
000000000000000000454000000000:000000000\
0000000000000000004540000000000000000000\
0000000000000000004540000000:00000000000\
0000000000000000004540000000000000000000\
000000000000000000454000000000:000000000\
0000000000000000004540000000000000000000\
0000000000000000004540000000:00000000000\
0000000000000000004540000000000000000000\
000000000000000000454000000000:000000000\
0000000000000006004540060000000000000000\
0000000000000000004540000000:00000000000\
0000000<000000000045400;0000000000000000\
0000005555555599955555555555555550000000",I:[[12,17,5,15,17]],J:[],ac:588},

// 29
{hash:"0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000200000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
0000000000000000000300000000000000000000\
00000000000<0<0<0<0300000000000000000000\
000000000F000000000300000000000000000000\
000000000G000000000300000000000000000000\
0000000033333333333333333333300000000000",I:[],J:[],txt:"By the way, did you notice that           cubes can glitch through walls?  ",txt2:"*wink wink            the theme*    ",ac:590},

// 30
{hash:"0033333000000000000000000000000000000<00\
0030F03000000000<<0000000000000000000000\
0030G0300000<<00000000<<0000<00000040000\
00300030000000<<0000<<000000000002000000\
0030003000000000<<0000<<0000000000000000\
003000300000<<0000<<00000000000000000000\
00300030000000<<0000<<000000000004000000\
003000300000<<00000000<<0000000000000000\
00300030000000<<000000000000000000000000\
003000300000<<00000000<<0000000000000000\
00300030000000<<0000<<000000000000000000\
003000300000<<00000000000000000000000000\
0030003000000000000000<<0000000000000000\
00000000000000<<0000<<000000000000000000\
000000000000<<00000000<<0000000000000000\
0000000000000000000000000000000000000000\
0000000000007777000077770000000000000000\
0008888888888888888888888888888888800000\
0000000000000000000000000000000000000000",I:[[16,16,8,19,7],[18,16,8,16,7],[33,11,16,28,5]],J:[[4,3,36,1],[4,4,37,6],[4,5,37,11],[4,6,37,16],[4,7,9,16],[4,8,-1,16],[4,9,1,-1],[28,4,28,6]],txt:"Thanks for playing! Please create and share levels now!",ac:540},

{hash:"0000000000F00000000000000000000000000000\
0000000000G00000000000000000000000000000\
0000034000000000000000000000000000000000\
0000033000000000000000000000000000000000\
0000000000000000000000000000000000000000\
0000000000077700000000000000000000000000\
0000000000033370000000000000000000000000\
0000000000033337000000000000000000000000\
0000000000033333700000000000000000000000\
0000000000033333370000000000000000000000\
0000000000033333337000000000000000000000\
0000000000033333333700000000000000000000\
0000000000033333333370000000000000000000\
0000000000033333333330000000000000000000\
0000000000033333333330000000000000000000\
0000000000033333330000000000000000000000\
0000000000033333330200000000000000000000\
0000040000033333330888000000000000000000\
0000000000000000000000000000000000000000",I:[],J:[],txt:"Okay, one last.",ac:57}

];

// Helpers
// =======

// Draw a 32x32 tile aligned on the grid
AA = (e, f, g) => {
  c.drawImage(b, e * 16, 0, 16, 16, f * 32, 40 + g * 32, 32, 32);
}

// Draw a 32x32 sprite anywhere (don't forget to add 40 to y to draw in the scene)
AB = (e, f, g) => {
  c.drawImage(b, e * 16, 0, 16, 16, f, g, 32, 32);
}

// Which tile is at these coordinates (in px)? (returns 0 by default)
AC = (e, f, g) => {
  if(!t.x[~~(f / 32)]){
    return 0;
  }
  return t.x[~~(f / 32)][~~(e / 32)] || 0;
}

// Set a tile in the current level at these coordinates (in px)
AD = (e, f, g) => {
  if(!t.x[~~(f / 32)]){
    return;
  }
  t.x[~~(f / 32)][~~(e / 32)] = g;
}

// Is a tile id currently Q? 
// Clouds are Q after a time travel
// (optionally, conTr spikes Q, because cubes can be placed on them)
AE = (e, f, g) => {
  return (e == 13 && Z != 0) || (f && e == 7) || Q[e] || 0;
}

// Is a tile writable (in the editor, a.k.a don't already contain a pipe or a balance or a time machine)
AF = (e, f, g) => {
  if(!t.x[r]){
    return 0;
  }
  return !t.x[f][e] || t.x[f][e] < 14 || t.x[f][e] > 21
}

// Reset a Z (after Qing a level / reversing time)
AG = (e,f,g) => {

  return {
    x: (t && t.Q) ? t.Q[0] * 32 : 640,
    y: (t && t.Q) ? t.Q[1] * 32 : 0,
    e: 0,
    f: 0,
    d: 0,
    D: ab || false,
    j: [],
    m: aa || false,
    l: [],
    E: ac || false,
    g: [],
    r: [],
    F: [],
    C: [],
    z: [],
    G: 0,
    i: 1, // 0: left, 1: right
    a: 0, // 0: idle, 1: walking, 2: jumping, 3: dead
    t: null,
    o: null,
    H: null,
    v: 0,
    n: true
  }
}

// Reset all the settings of the current level (before playing : 0 / before going back in time: 1)
AH = (e,f,g) => {
  
  // Reset I condition
  I = false;
  M = 0;
  J = 0;
  K = 0;
  L = 0;

  // Current N
  N = 0;

  // Reset "present" Z
  O = AG();

  // Qity of the tiles (some of them vary during gameplay, so we reset it before each level and after reset)
  Q = [
    0, // 0: sky
    0, // 1: time machine placeholder
    0, // 2: flag
    1, // 3: ground
    1, // 4: portalable wall
    1, // 5: brick
    0, // 6: coin
    0, // 7: spike
    1, // 8: ice
    1, // 9: Q yellow block
    0, // 10: non-Q yellow block
    0, // 11: yellow toggle
    0, // 12: cube
    0, // 13: cloud
    1, // 14: pipe placeholder
    0, // 15: Balance
    1, // 16: pipe top left
    1, // 17: pipe top right
    1, // 18: pipe body left
    1, // 19: pipe body right
    1, // 20: Green switch
    0, // 21: Green switch L
    0, // 22: Tardis top
    0, // 23: Tardis bottom
    0, // 24: flag pole
    0  // 25: yellow toggle L
  ];
  
  // Cubes (parsed at N 0)
  t.u = [];
  
  // Yellow toggles state at last N
  U = false
  
  // Pipes state
  V = [];
  
  // Balances state
  W = [];
  
  // Portals
  X = { q: -1, r: -1 };
  Y = { q: -2, r: -2 };
  
  // Heros (playing simultaneously after time travels)
  if(!e){
    ae = [];
  }
}

// Make an empty level (for the editor)
AI = (e,f,g) => {
  
  // Editor's level data
  t = {
    x: [],
    I: [],
    J: [],
    u: [],
    K: false
  }

  for(j = 0; j < 20; j++){
    t.x[j] = [];
  }

  // Pipes
  pipe_click = 0;
  v = 0;

  // Balances
  w = 0;
  z = 0;
  
  // Current tile in the level editor (0: sky / 1: Q / etc.)
  A = 0;
  
  // Reset ability to quit
  G = true;
  H = false;
};

// First N inits (also happen after time travels)
AJ = (e,f,g) => {
  
  AH(1);
    
  // Build map from hash
  t.x = [];
  for(var j = 0; j < 20; j++){
    t.x[j] = [];
    for(var i = 0; i < 40; i++){
      
      t.x[j][i] = t.hash.charCodeAt(j * 40 + i) - 0x30;

      // Ignore tile #15 / "?" / balanced platforms placeholders.
      if(t.x[j][i] == 15){
        t.x[j][i] = 0
      }
    }
  }
  
  // Init pipes states
  for(var i in t.I){
    V[i] = {L: false, y: t.I[i][1] * 32};
  }
  
  // Init balances states (on first N)
  for(var i in t.J){
    W[i] = {O: t.J[i][1] * 32 , P: t.J[i][3] * 32, M: 0, N: 0};
  }
}

// Parse and draw map (at each N, but if we're on N 0, also set Q coordinates, initialize cubes and build flag pole)
AK = (e,f,g) => {
  for(j = 0; j < 20; j++){
    for(i = 0; i < 40; i++){
      
      // Current tile
      F = t.x[j][i];
      
      // Tile #12: cube (register it in t.u and remove it from the tiles)
      if(F == 12){
        F = 0;
        if(N == 0){
          t.u.push({x: i * 32, y: j * 32, f: 0, Z: null});
        }
      }
      
      // Tile #13 and not time traveled yet: transparent cloud
      if(F == 13 && ae.length == 0){
        c.save();
        c.globalAlpha = 0.5;
        AA(F, i, j);
        c.restore();
      }
      
      // Else, any tile is opaque
      else {
        AA(F, i, j);
      }
      
      // Tile #2: flag pole (make it touch the ground)
      if(F == 2 && N == 0){
        E = false;
        if(j < 20){
          for(k = j + 1; k < 20; k++){
            if(!t.x[k][i] && !E){
              AA(24, i, k);
              t.x[k][i] = 24;
            }
            else{
              E = true;
            }
          }
        }
      }
      
      // Tile #23: time machine (save Qing point coordinates, place Z there at first N)
      if(F == 23 && N == 0){
        t.Q = [i, j];
        O.x = t.Q[0] * 32;
        O.y = t.Q[1] * 32;
      }
    }
  }
  
  // N 0: re-place all past ae at the Q position and reset their movement properties
  if(N == 0){
    
    for(Z in ae){
      ae[Z].x = t.Q[0] * 32;
      ae[Z].y = t.Q[1] * 32;
      ae[Z].e = 0;
      ae[Z].f = 0;
      ae[Z].D = false;
      ae[Z].m = false;
      ae[Z].E = false;
      ae[Z].q = false;
      ae[Z].i = 1;
      ae[Z].s = 0;
      ae[Z].t = null;
      ae[Z].o = null;
      ae[Z].H = null;
    }
    for(i in t.u){
      t.u[i].Z = null;
    }
  }
}

// Apply gravity and collisions to a given eect (g 0: Z, g 1: cube), plus make it enter in ag
AL = (e, f, g) => {
  
  // compute eect's R
  if(typeof e.t != "undefined" && e.t !== null){
    e.R = 1 + t.u[e.t].R;
  }
  
  // Follow the cube below and forget it until next N
  if(e.o !== null && e.o != e.t){
    e.x = t.u[e.o].x + e.H;
    e.y = t.u[e.o].y - 32;
    e.o = null;
  }

  // Go right
  if(e.e > 0){
    
    e.S = null;
    
    // Enter a portal on the right (tile 4 + portal on position 3 (left) + other portal exists)
    if(
      AC(e.x + f + e.e, e.y + 16) == 4
      &&
      Y.q >= 0
      &&
      X.q == ~~((e.x + f + e.e) / 32)
      &&
      X.r == ~~((e.y + 16) / 32)
      &&
      X.T == 3
    ){
      e.S = Y;
    }
    
    if(
      AC(e.x + f + e.e, e.y + 16) == 4
      &&
      X.q >= 0
      &&
      Y.q == ~~((e.x + f + e.e) / 32)
      &&
      Y.r == ~~((e.y + 16) / 32)
      &&
      Y.T == 3
    ){
      e.S = X;
    }
    
    // If the eect is entering a portal
    if(e.S){
      
      // Adjust position and speed
      e.y = ~~((e.y + 16) / 32) * 32;
      e.f = 0;
      e.k = true;
      
      // U and maintain the speed for a few Ns if the eect's left T entered the portal's tile
      if(AC(e.x + e.e, e.y + 16) == 4){
        e.U = true;
        e.V = Math.max(e.e, 6);
        e.e = 0;
        e.c = 8;
      }
    }
    
    // Stop going right if there's a Q tile or the end of the screen on the right
    else if(
      AE(AC(e.x + f + e.e, e.y))
      ||
      AE(AC(e.x + f + e.e, e.y + 31))
    ){
      e.x = ~~((e.x + e.e) / 32) * 32 + 32 - f - 1;
      e.e = 0;
    }
    
    if(e.x > 1280 - f){
      e.x = 1280 - f;
      e.e = 0;
    }
    
    // Stop going right if there's a pipe there
    for(var j in t.I){
      if(
        !e.k
        &&
        e.x + f + e.e >= t.I[j][0] * 32
        &&
        e.x + f + e.e  <= t.I[j][0] * 32 + 16
        &&
        e.y + 31 >= V[j].y
        &&
        e.y <= V[j].W
      ){
        e.x = t.I[j][0] * 32 - f - 1;
        e.e = 0;
      }
    }
  }
  
  // Go left
  if(e.e < 0){
  
    e.S = null;
    
    // Enter a portal on the left (tile 4 + portal on position 1 (right) + other portal exists)
    if(
      AC(e.x + e.e, e.y + 16) == 4
      &&
      Y.q >= 0
      &&
      X.q == ~~((e.x + e.e) / 32)
      &&
      X.r == ~~((e.y + 16) / 32)
      &&
      X.T == 1
    ){
      e.S = Y;
    }
    
    if(
      AC(e.x + e.e, e.y + 16) == 4
      &&
      X.q >= 0
      &&
      Y.q == ~~((e.x + e.e) / 32)
      &&
      Y.r == ~~((e.y + 16) / 32)
      &&
      Y.T == 1
    ){
      e.S = X;
    }
      
    // If the eect is entering a portal
    if(e.S){
      
      // Adjust position and speed
      e.y = ~~((e.y + 16) / 32) * 32;
      e.f = 0;
      e.k = true;
      
      // U and maintain the speed for a few Ns if the eect's right T entered the portal's tile
      if(AC(e.x + e.e + f, e.y + 16) == 4){
        e.U = true;
        e.V = Math.max(-e.e, 6);
        e.e = 0;
        e.c = 8;
      }
    }
    
    // Stop going left if there's a Q tile or end of the level on the left
    else if(
      AE(AC(e.x + e.e, e.y))
      ||
      AE(AC(e.x + e.e, e.y + 31))
    ){
      e.x = ~~((e.x + e.e) / 32) * 32 + 32;
      e.e = 0;
    }
    if(e.x < 0){
      e.x = 0;
      e.e = 0;
    }
    
    // Stop going left if there's a pipe there
    for(j in t.I){
      if(
        e.x + e.e >= t.I[j][0] * 32 + 64 - 16
        &&
        e.x + e.e <= t.I[j][0] * 32 + 64
        &&
        e.y + 31 >= V[j].y
        &&
        e.y <= V[j].W
      ){
        e.x = t.I[j][0] * 32 + 64;
        e.e = 0;
      }
    }
  }
  
  // Apply horizontal speed
  e.x += e.e;
  
  // Apply gravity if eect is not in a portal, and compute vertical speed
  if(!e.k){
    e.d = false;
    e.f += 2;
    if(e.f > 24){
      e.f = 24;
    }
  }
  
  // Go down
  if(e.f > 0){
    
    e.S = null;
    
    // Enter a portal on the bottom (tile 4 + portal on position 0 (top) + other portal exists)
    if(
      AC(e.x + f / 2, e.y + 32 + e.f) == 4
      &&
      Y.q >= 0
      &&
      X.q == ~~((e.x + f / 2) / 32)
      &&
      X.r == ~~((e.y + 32 + e.f) / 32)
      &&
      X.T == 0
    ){
      e.S = Y;
    }
    
    if(
      AC(e.x + e.e / 2, e.y + 32 + e.f) == 4
      &&
      X.q >= 0
      &&
      Y.q == ~~((e.x + f / 2) / 32)
      &&
      Y.r == ~~((e.y + 32 + e.f) / 32)
      &&
      Y.T == 0
    ){
      e.S = X;
    }
      
    // If the eect is entering a portal
    if(e.S){
      
      // Adjust position and speed
      e.x = ~~((e.x + f / 2) / 32) * 32 + (32 - f) / 2;
      e.e = 0;
      e.k = true;
      
      // U and maintain the speed for a few Ns if the eect's top T entered the portal's tile
      if(
        // Low speed
        (e.f < 10 && AC(e.x + f / 2, e.y + 32 + e.f - 16) == 4)
        ||
        
        // High speed
        (e.f > 10 && AC(e.x + f / 2, e.y + 32 + e.f) == 4)
      ){
        e.U = true;
        e.V = Math.max(e.f, 6);
        e.f = 0;
        e.c = 8;
      }
    }
  
    // Stop falling if a Q tile is under eect (or a spike, if the eect is a cube)
    else if(
      AE(AC(e.x, e.y + 32 + e.f))
      ||
      AE(AC(e.x + f - 1, e.y + 32 + e.f))
      ||
      (g == 1 && AC(e.x, e.y + 32 + e.f) == 7)
      ||
      (g == 1 && AC(e.x + f - 1, e.y + 32 + e.f) == 7)
    ){
      e.y = ~~((e.y + e.f) / 32) * 32;
      e.f = 0;
      e.d = true;
    }
    
    // Stop falling if a cube is under eect (only if the cube and the eect are not in a portal)
    for(i in t.u){
      if(
        !t.u[i].k
        &&
        !e.k
        &&
        e.x + f > t.u[i].x
        &&
        e.x < t.u[i].x + 32
        &&
        e.y + 31 + e.f > t.u[i].y - 8
        &&
        e.y + 31 + e.f < t.u[i].y + 20
      ){
        e.y = t.u[i].y - 32;
        e.f = 0;
        e.d = true;
        e.o = i;
        e.H = e.x - t.u[i].x;
        t.u[i].R += e.R;
      }
    }
    
    // Stop falling if there's a pipe there
    for(j in t.I){
      if(
        e.x + f - 1 >= t.I[j][0] * 32
        &&
        e.x < t.I[j][0] * 32 + 64
        &&
        e.y + 31 + e.f >= V[j].y
        &&
        e.y + 31 + e.f <= V[j].y + 32
      ){
        e.y = V[j].y - 32;
        e.f = 0;
        e.d = true;
        e.b = true;
      }
    }
    
    // Stop falling if there's a balance "1" there
    for(j in t.J){
      if(
        e.x + f >= t.J[j][0] * 32 - 32
        &&
        e.x < t.J[j][0] * 32 + 64
        &&
        e.y + 31 + e.f >= W[j].O - 8
        &&
        e.y + 31 + e.f <= W[j].O + 32
      ){
        e.y = W[j].O - 32;
        e.f = 0;
        e.d = true;
        e.b = true;
        W[j].M += e.R;
      }
    }
    
    // Stop falling if there's a balance "2" there
    for(j in t.J){
      if(
        e.x + f >= t.J[j][2] * 32 - 32
        &&
        e.x < t.J[j][2] * 32 + 64
        &&
        e.y + 31 + e.f >= W[j].P - 8
        &&
        e.y + 31 + e.f <= W[j].P + 32
      ){
        e.y = W[j].P - 32;
        e.f = 0;
        e.d = true;
        e.b = true;
        W[j].N += e.R;
      }
    }
  }
  
  // Go up (only for Z)
  if(e.f < 0){
    
    e.S = null;
    
    // Enter a portal on top (tile 4 + portal on position 2 (bottom) + other portal exists)
    if(
      AC(e.x + f / 2, e.y + e.f) == 4
      &&
      Y.q >= 0
      &&
      X.q == ~~((e.x + f / 2) / 32)
      &&
      X.r == ~~((e.y + e.f) / 32)
      &&
      X.T == 2
    ){
      e.S = Y;
    }
    
    if(
      AC(e.x + e.e / 2, e.y + e.f) == 4
      &&
      X.q >= 0
      &&
      Y.q == ~~((e.x + f / 2) / 32)
      &&
      Y.r == ~~((e.y + e.f) / 32)
      &&
      Y.T == 2
    ){
      e.S = X;
    }
      
    // If the eect is entering a portal
    if(e.S){
      
      // Adjust position and speed
      e.x = ~~((e.x + f / 2) / 32) * 32 + (32 - f) / 2;
      e.e = 0;
      e.k = true;
      
      // U and maintain the speed for a few Ns if the eect's bottom T entered the portal's tile
      if(AC(e.x + f / 2, e.y + e.f + 10) == 4){
        e.U = true;
        e.V = 6;
        e.f = 0;
        e.c = 8;
      }
    }
    
    // Stop going up if there's a Q tile on top (only for Z)
    else if(
      AE(AC(e.x, e.y + e.f))
      ||
      AE(AC(e.x + f, e.y + e.f))
    ){
      
      // Break bricks (tile #5 => tile #0)
      if(AC(e.x, e.y + e.f) == 5){
        AD(e.x, e.y + e.f, 0);
        mkaudio(SNDbrick1).play();
      }
      if(AC(e.x + 24, e.y + e.f) == 5){
        AD(e.x + 24, e.y + e.f, 0);
        mkaudio(SNDbrick1).play();
      }
      
      e.y = ~~((e.y + e.f) / 32) * 32 + 32;
      e.f = 0;
    }
  }
  
  // Update position according to vertical speed
  e.y += e.f;
  
  
  // U
  if(e.U){
    e.U = false;
    e.d = false;
    mkaudio(SNDwhat0).play();
    
    e.x = e.S.q * 32 + (32 - f) / 2;
    e.y = e.S.r * 32;
    
    // Top 
    if(e.S.T == 0){
      e.f = -e.V;
      e.e = 0;
    }
    
    // right
    if(e.S.T == 1){
      e.e = e.V;
      e.f = 0;
      e.x += 8;
    }
    
    // bottom
    if(e.S.T == 2){
      e.f = e.V;
      e.e = 0;
      
      // Ensure the Z falls off the portal and is controllable soon
      e.y += 8;
      e.c = 2;
    }
    
    // left
    if(e.S.T == 3){
      e.e = -e.V;
      e.f = 0;
      e.x -= 8;
    }
  }
  
  // Press yellow switch (at the bottom left or right)
  if(AC(e.x, e.y + 20) == 11){
    AD(e.x, e.y + 20, 25);
    R = true;
  }
  else if(AC(e.x + f, e.y + 20) == 11){
    AD(e.x + f, e.y + 20, 25);
    R = true;
  }
  
  // Press green switch
  for(var i in t.I){
    if(
      e.x + f >= t.I[i][3] * 32
      &&
      e.x <= t.I[i][3] * 32 + 32
      &&
      e.y + 32 >= t.I[i][4] * 32
      &&
      e.y + 20 <= t.I[i][4] * 32 + 32
    ){
      V[i].L = true;
    }
  }
}

// Play or replay a given Z (past: 1 / present: 0)
AM = (e, f, g) => {
  
  // If he's not dead and didn't I yet
  if(e.a != 3 && !I && !L){
    
    // Reset to idle state, conTr he's not on a moving object
    e.a = 0;
    e.b = false;
    
    // If we're not in the few Ns that follow a portal Uation
    if(!e.c){

      // Cancel vx (if Z not on ice and not in the air or in the air but without horizontal V)
      if(
        (
          e.d
          &&
          AC(e.x, e.y + 33) != 8
          &&
          AC(e.x + 24, e.y + 33) != 8
        )
        ||
        (
          !e.d
          &&
          Math.abs(e.e) < 10
        )
      ){
        e.e = 0;
      }
    
      // Go right (unless if in portal, or being Ued, or slipping left on ice)
      if(
        e.g[N]
        &&
        !(
          (
            AC(e.x, e.y + 33) == 8
            ||
            AC(e.x + 24, e.y + 33) == 8
          )
          &&
          e.e != 0
        )
      ){
        if(e.i == 1){
          e.e = Math.max(e.e, 6);
        }
        else {
          e.e = 0
        }
        e.i = 1;
        
        // Walk animation
        if(e.d){
          e.a = 1;
        }
      }
      
      // Go left (unless if in portal, or being Ued, or slipping right on ice)
      if(
        e.j[N]
        &&
        !(
          (
            AC(e.x, e.y + 33) == 8
            ||
            AC(e.x + 24, e.y + 33) == 8
          )
          &&
          e.e != 0
        )
      ){
        if(e.i == 0){
          e.e = Math.min(e.e, -6);
        }
        else {
          e.e = 0
        }
        e.i = 0;
        
        // Walk animation
        if(e.d){
          e.a = 1;
        } 
      }
    }
    
    // Jump (if not in a portal and not slipping on ice)
    if(
      !e.k
      &&
      e.l[N]
      &&
      e.d
      &&
      !(
        (
          AC(e.x, e.y + 33) == 8
          ||
          AC(e.x + 24, e.y + 33) == 8
        )
        &&
        e.e != 0
      )
    ){
      e.f -= 20;
      e.d = false;
      e.m = false;
      e.n = false;
      e.o = null;
      mkaudio(SNDjump2).play();
    }
    
    // Jump sprite
    if(e.f < 0 && !e.d){
      e.a = 2;
    }
    
    // Apply gravity and collsions
    AL(e, 24, 0);
    
    // Collect coins (tile 6 => tile 0)
    if(AC(e.x + 24 / 2 - 8, e.y + 16 - 8) == 6 ){
      AD(e.x + 24 / 2 - 8, e.y + 16 - 8, 0);
      mkaudio(SNDcoin1).play();
    }
    if(AC(e.x + 24 / 2 + 8, e.y + 16 - 8) == 6){
      AD(e.x + 24 / 2 + 8, e.y + 16 - 8, 0);
      mkaudio(SNDcoin1).play();
    }
    if(AC(e.x + 24 / 2 - 8, e.y + 16 + 8) == 6){
      AD(e.x + 24 / 2 - 8, e.y + 16 + 8, 0);
      mkaudio(SNDcoin1).play();
    }
    if(AC(e.x + 24 / 2 + 8, e.y + 16 + 8) == 6){
      AD(e.x + 24 / 2 + 8, e.y + 16 + 8, 0);
      mkaudio(SNDcoin1).play();
    }
    
    // Press Shift
    if(e.F[N]){
      
      // If in front of the time machine (tile #23)
      if(
        AC(e.x, e.y) == 23
        ||
        AC(e.x + 24, e.y) == 23
        ||
        AC(e.x, e.y + 31) == 23
        ||
        AC(e.x + 24, e.y + 31) == 23
      ){
        
        // Present Z: remember the N and add it to the array of f ae and go back to the beginning of time (N -1)
        if(!f){
          e.p = N;
          ae.push(e);
          N = -1;
          O = AG();
        }
        
        // f Z: remember that he's safe
        else{
          e.q = true;
        }
        
        mkaudio(SNDtimetravel0).play();
      }
    }
    
    // Die (spike)
    if(
      AC(e.x + 3, e.y) == 7
      ||
      AC(e.x + 24 - 3, e.y) == 7
      ||
      AC(e.x + 3, e.y + 5) == 7
      ||
      AC(e.x + 24 - 3, e.y + 5) == 7
    ){
      e.a = 3;
      e.f = -1 * 20;
    }
    
    // Die (fall)
    if(e.y > 648){
      e.a = 3;
      e.f = -1.5 * 20;
    }
    
    // Die (if a Q yellow block (#9) appears on top of the Z)
    if(
      (AC(e.x + 1, e.y + 1) == 9)
      ||
      (AC(e.x + 24 - 1, e.y + 1) == 9)
      ||
      (AC(e.x + 1, e.y + 31) == 9)
      ||
      (AC(e.x + 24 - 1, e.y + 31) == 9)
    ){
      e.a = 3;
      e.f = -1.5 * 20;
    }
    
    // Die (crush between a pipe or a balance and a Q tile)
    if(
      e.b
      &&
      (
        (
          AE(AC(e.x, e.y + 1))
          ||
          AE(AC(e.x + 24, e.y + 1))
        )
      )
    ){
      e.a = 3;
      e.f = -1 * 20;
    }
    
    // Pick/drop cube toggle
    if(e.r[N]){
      e.s ^= 1;
    }
    
    // Pick cube
    if(e.s){
      if(e.t === null){
        for(i in t.u){
          if(
            e.x + 24 >= t.u[i].x
            &&
            e.x <= t.u[i].x + 31
            &&
            e.y + 31 + 4 >= t.u[i].y
            &&
            e.y <= t.u[i].y + 31
          ){
            e.t = i;
            t.u[i].Z = e;
            e.v = 5;
            break;
          }
        }
      }
    }
    
    // Drop cube
    else if($ = t.u[e.t]){
      
      $.x = e.x;
      $.o = null;

      // Throw it if Z is not grounded
      if(!e.d){
        
        // Left
        if(e.i == 0){
          $.e = -14;
        }
        
        // Right
        else{
          $.e = 14;
        }
      }
      
      // Avoid collisions
      if(AE(AC($.x, $.y))){
        $.x = ~~(($.x) / 32) * 32 + 32;
      }
      else if(AE(AC($.x, $.y + 31))){
        $.x = ~~(($.x) / 32) * 32 + 32;
      }
      else if(AE(AC($.x + 32, $.y))){
        $.x = ~~(($.x) / 32) * 32 - 1;
      }
      else if(AE(AC($.x + 32, $.y + 31))){
        $.x = ~~(($.x) / 32) * 32 - 1;
      }
        
      $.Z = null;
      t.u[e.t] = $;
      e.t = null;
      e.R = 1;
    }
    
    // Hold cube
    if(e.t !== null){
      
      // Left
      if(e.i == 0){
        t.u[e.t].x = e.x - 6;
      }
      if(e.i == 1){
        t.u[e.t].x = e.x - 4;
      }
      
      // Animate cube grab (make it last 5 Ns)
      if(e.v){
        e.v--;
      }
      
      // Place cube over Z (unless he's passing through a portal or there's a Q tile above, in this case hold it lower)
      if(e.k){ 
        t.u[e.t].y = e.y;
      }
      else if(AE(AC(e.x, e.y - 28)) || AE(AC(e.x + 24, e.y - 28))){
        t.u[e.t].y = ~~((e.y + 4) / 32) * 32;
      }
      else{
        t.u[e.t].y = e.y - 32 + e.v * 4;
      }
    }
    
    // If no cube is held, cancel space key
    else {
      e.s = 0;
    }
    
    // I (all coins gathered and touch flag)
    if(AC(e.x + 24 / 2, e.y + 16) == 2 || AC(e.x + 24 / 2, e.y + 16) == 24){
      M = 0;
      for(j = 0; j < 20; j++){
        for(i = 0; i < 40; i++){
          if(t.x[j][i] == 6){
           M++;
          }
        }
      }
      if(M == 0){
        I = true;
        e.a = 0;
      }
    }
    
    // Send ag (only if Z's not currently in a portal)
    if(!e.k && (e.C[N] || e.z[N])){
    
      mkaudio(SNDshoot1).play();
        
      // Cancel current shoots
      e.A = 0;
      e.B = 0;
      
      // Left click: current Z sends a blue portal
      if(e.C[N]){
        e.A = 1;
        
        // Compute the angle made by the line "Z - click coordinates" and the horizontal axis
        e.G = Math.atan2(e.C[N][0] - (e.x + 24 / 2), e.C[N][1] - (e.y + 40 + 16));
      }
      
      // Right click: current Z sends a orange portal
      if(e.z[N]){
        e.B = 1;
        
        // Compute the angle made by the line "Z - click coordinates" and the horizontal axis
        e.G = Math.atan2(e.z[N][0] - (e.x + 24 / 2), e.z[N][1] - (e.y + 40 + 16));
      }
      
      // Compute portal beam movement
      e.X = e.x + 24 / 2;
      e.Y = e.y + 16;
      e.Z = Math.sin(e.G);
      e.aa = Math.cos(e.G);
    }
    
    // Portal beam (reflect on ice / open portal on white wall)
    for(ah in ag = [["A", X, "blue"], ["B", Y, "orange"]]){
    
      if(e[ag[ah][0]]){
      
        // Make beam advance with baby steps
        for(i = 0; i < 40; i++){
          e[ag[ah][0]] += .001;
          e.X += e[ag[ah][0]] * e.Z;
          e.Y += e[ag[ah][0]] * e.aa;
          
          // If beam hits Q or spike (tile #7)
          if(AE(AC(e.X, e.Y)) || AC(e.X, e.Y) == 7){
            
            // Cancel any existing portal of this color
            e[ag[ah][0]] = 0;
            
            // Define on which T the portal goes (0: top, 1: right, 2: bottom, 3: left)
            // Avoid opening a portal between two Q tiles, and on Ts not reachable given the current angle
            if(e.X % 32 < 4 && !AE(AC(e.X - 32, e.Y)) && e.Z > 0){
              m = 3;
            }
            if(e.X % 32 > 28 && !AE(AC(e.X + 32, e.Y)) && e.Z < 0){
              m = 1;
            }
            if(e.Y % 32 < 4 && !AE(AC(e.X, e.Y - 32)) && e.aa > 0){
              m = 0;
            }
            if(e.Y % 32 > 28 && !AE(AC(e.X, e.Y + 32)) && e.aa < 0){
              m = 2;
            }

            // Reflect ray if tile is #8 (ice)
            if(AC(e.X, e.Y) == 8){
            
              mkaudio(SNDshoot1).play();
              e[ag[ah][0]] = 1;
              if(m == 0){
                e.aa = -e.aa;
                e.Y = ~~(e.Y / 32) * 32 - 1;
              }
              else if(m == 2){
                e.aa = -e.aa;
                e.Y = ~~(e.Y / 32) * 32 + 32 + 1;
              }
              else if(m == 1){
                e.Z = -e.Z;
                e.X = ~~(e.X / 32) * 32 + 32 + 1;
              }
              else
              {
                e.Z = -e.Z;
                e.X = ~~(e.X / 32) * 32 - 1;
              }
            }
            
            // Place portal if tile is #4 (white wall) and no orange portal is here yet
            if(
              AC(e.X, e.Y) == 4
              &&
              (~~(e.X / 32) != ag[1 - ah][1].q || ~~(e.Y / 32) != ag[1 - ah][1].r || ag[1 - ah][1].T != m)
            ){
              ag[ah][1].q = ~~(e.X / 32);
              ag[ah][1].r = ~~(e.Y / 32);
              ag[ah][1].T = m;
              mkaudio(SNDwhatportal2).play();
            }
            break;
          }
          else{
            c.fillStyle = ag[ah][2];
            c.fillRect(e.X, e.Y + 40, 6, 6);        
          }
        }
      }
    }
    
    // If Z is not in a #4 Q tile, assume he's not in a portal
    if(
      AC(e.x + 1, e.y + 1) != 4
      &&
      AC(e.x + 24 - 1, e.y + 1) != 4
      &&
      AC(e.x + 1, e.y + 31) != 4
      &&
      AC(e.x + + 24 - 1, e.y + 31) != 4
    ){
      e.k = false;
    }
    
    // Decrement Uation idle delay
    if(e.c){
      e.c--;
    }
  }
  
  // Death animation
  if(e.a == 3){
    e.f += 2;
    if(e.f > 24){
      e.f = 24;
    }
    e.y += e.f;
  }
}

// Draw a Z (past: 1 / present: 0)
AN = (e, f, g) => {
  c.save();
  
  // Go to the Z's position
  c.translate(e.x + 24 / 2 - 2, e.y);
  
  // Facing left
  if(e.i == 0){
    c.scale(-1, 1);
  }
    
  // Past: alpha 0.5
  if(f){
    c.globalAlpha = 0.75;
  }
  
  // Present and past ae exist: add arrow to present
  else if(ae.length){
    c.fillStyle = "#fff";
    c.fillText("▼", 0, 10);
  }

  // Draw (except if it's a past Z that has finished playing)
  if(! (f && N > e.p)){
    c.drawImage(b, [26, [27,28,29][~~(N / 2) % 3], 30, 31][e.a] * 16, 0, 16, 16, - 24 / 2, 40, 32, 32);
  }
  
  c.restore();
}

// Input
// =====

// Handle clicks on the canvas on each screen
onclick = oncontextmenu = (e, f, g) => {
  AO(e);
  return false;
}

// On mouse down, set a mousedown flag and a rightclick flag (if right click is down)
onmousedown = (e, f, g) => {
  o = true;
  if(e.which == 3){
    p = true;
  }
  else{
    p = false;
  }
}

// On mouse up, reset the mousedown flag
onmouseup = (e,f,g) => {
  o = false;
}

// On mouse move:
onmousemove = (e,f,g) => {
  
  // Compute mouse coords in px and in tiles
  x = e.pageX - a.getBoundingClientRect().left - document.documentElement.scrollLeft - document.body.scrollLeft;
  y = e.pageY - a.getBoundingClientRect().top - document.documentElement.scrollTop - document.body.scrollTop;
  q = Math.floor(x / 32);
  r = Math.floor((y - 40) / 32);
  
  // Level editor only
  if(d == 3){
    
    // ConTr mousedown + mousemove like clicks (unless we're placing a pipe or a balance)
    if(o && A != 14 && A != 15){
      AO(e);
    }
    
    // In every case: redraw the d to show the tiles freshly placed and the tile being placed.
    AP(1);
  }
}

// Handle clicks
AO = (e,f,g) => {
    
  // Main menu
  if(d == 0){

    // Music
    c.beginPath();
    c.rect(1230, 0, 90, 90);
    if(c.isPointInPath(x, y)){
      mute = !mute;
      if(mute){
        MM.stop();
      }
      else {
        Music();
      }
      AP();
    }
    c.closePath();
    
    // Button 1 (play): display level selection screen
    c.beginPath();
    c.rect(500, 400, 100, 80);
    if(c.isPointInPath(x, y)){
      d = 1;
      AP();
    }
    c.closePath();
    
    // Button 2 (make): redirect to level editor
    c.beginPath();
    c.rect(650, 400, 100, 80);
    if(c.isPointInPath(x, y)){
      d = 3;
      AI();
      AP();
    }
    c.closePath();
  }
  
  // Level selection menu
  if(d == 1){
    
    // Back button
    c.beginPath();
    c.rect(30, 30, 50, 50);
    if(c.isPointInPath(x, y)){
      d = 0;
      AP();
    }
    c.closePath();
    
    // G levels
    c.beginPath();
    c.rect(590, 520, 100, 80);
    if(c.isPointInPath(x, y)){
      open("//goo.gl/oBx0S1");
    }
    c.closePath();
    
    // Levels
    for(i = 0; i < 10; i++){
      for(j = 0; j < 3; j++){
        m = j * 10 + i + 1;
        if(+localStorage["scpm"] >= m){
          c.beginPath();
          c.rect(i * 120 + 50, j * 100 + 120, 100, 80);
          if(c.isPointInPath(x, y)){
            n = 1;
            d = 2;
            _ = 0;
            s = m;
            t = levels[m];
            AP();
          }
          c.closePath();
        }
      }
    }
    if(+localStorage["scpm"] >= 30){
      c.beginPath();
      c.rect(50, 420, 100, 80);
      if(c.isPointInPath(x, y)){
        n = 1;
        d = 2;
        _ = 0;
        m=31;
        s = m;
        t = levels[m];
        AP();
      }
      c.closePath();
    }
  }
  
  // In-game
  if(d == 2 && N > 0){
    
    // Save click coordinates
    if(e.which == 1){
      O.C[N] = [x, y];
    }
    
    if(e.which == 3){
      O.z[N] = [x, y];
    }
    
    // Quit
    c.beginPath();
    c.rect(1240, 0, 32, 32);
    if(c.isPointInPath(x, y)){
      clearInterval(ad);
      d = n;
      AP();
    }
    c.closePath();
  }
  
  // Level editor
  if(d == 3){
  
    // Build a hash with all the tiles #0 - #15 and #20 - #22 (i.e. all except pipes and pipe switches)
    t.hash = "";
    for(j = 0; j < 20; j++){
      for(i = 0; i < 40; i++){
        tile = t.x[j][i] || 0;
        tile = (tile < 16 || tile > 21) ? tile : 0;
        t.hash += String.fromCharCode(tile + 0x30);
      }
    }

    // Test
    c.beginPath();
    c.rect(750, 4, 100, 32);
    if(c.isPointInPath(x, y)){
      n = 3;
      d = 2;
      AP();
    }
    c.closePath();
    
    // Share
    c.beginPath();
    c.rect(875, 4, 100, 32);
    if(c.isPointInPath(x, y)){
      location.hash = "";
      if(t.K == false){
        alert("You need to test and I your level first.");
      }
      else {
        open("//www.twitter.com/intent/tweet?text=" + encodeURIComponent("I made a level for #SuperChronoPortalMaker !\nPlay the game here: " + location.origin + location.pathname + ". \nPlay my level here:" + encodeURI(location.origin + location.pathname + "#" + JSON.stringify({hash:t.hash, I:t.I, J: t.J})) + "\nPlz RT"));
        G = true;
      }
    }
    c.closePath();
    
    // Clear
    c.beginPath();
    c.rect(1000, 4, 100, 32);
    if(c.isPointInPath(x, y)){
      AI();
      AP();
    }
    c.closePath();
    
    // Exit
    c.beginPath();
    c.rect(1125, 4, 100, 32);
    if(c.isPointInPath(x, y)){
      if(G || (!G && confirm("Quit? This level will be lost!"))){
        d = 0;
        AP();
      }
    }
    c.closePath();
    
    // Tileset (choose a tile), unless we're placing a pipe or a balance
    for(i = 0; i < 16; i++){
      c.beginPath();
      c.rect(8.5 + i * 35, 3.5, 32, 32);
      if(c.isPointInPath(x, y) && pipe_click == 0 && w == 0){
        
        // Chosen tile
        H = true;
        A = i;
        
        // Pipe: init a pipe object
        if(A == 14){
          t.I[v] = [];
        }
        
        // Balance: init a balance object
        if(A == 15){
          t.J[z] = [];
        }
        
        // Redraw entire screen (to show the active tile of the tileset)
        AP();
      }
      c.closePath();
    }
    
    // Click on the grid (to place a tile)
    c.beginPath();
    c.rect(0, 40, 1280, 608);
    if(c.isPointInPath(x, y)){
      
      // Reset G flag
      if(H){
        G = false;
      }
      
      // Mark the level as untested because it has changed
      t.K = false;
      
      // Save and draw placed tile.
      
      // Right click: erase (place sky / tile #0 instead of current tile)
      if(p == true){
        
        // Erase time machine
        // Top
        if(t.x[r][q] == 22){
          t.x[r][q] = 0;
          t.x[r + 1][q] = 0;
        }
        // Bottom
        if(t.x[r][q] == 23){
          t.x[r][q] = 0;
          t.x[r - 1][q] = 0;
        }
        
        // If the tile is writable
        if(AF(q, r)){
          t.x[r][q] = 0;
        }
        
        // Erase pipe if we click on tile #16 or #17 (pipe top)
        if(pipe_click == 0){
          if(t.x[r][q] == 16){
            for(i in t.I){
              if(t.I[i][0] == q && (t.I[i][1] == r || t.I[i][2] == r)){
                for(j = t.I[i][1]; j < 20; j++){
                  if(t.x[j][q] == 16 || t.x[j][q] == 18){
                    t.x[j][q] = 0;
                    t.x[j][q + 1] = 0;
                  }
                  else{
                    break;
                  }
                }
                for(j = t.I[i][2]; j < 20; j++){
                  if(t.x[j][q] == 16 || t.x[j][q] == 18){
                    t.x[j][q] = 0;
                    t.x[j][q + 1] = 0;
                  }
                  else{
                    break;
                  }
                }
                t.x[t.I[i][4]][t.I[i][3]] = 0;
                delete t.I[i];
              }
            }
          }
          
          if(t.x[r][q] == 17){
            for(i in t.I){
              if(t.I[i][0] == (q - 1) && (t.I[i][1] == r || t.I[i][2] == r)){
                for(j = t.I[i][1]; j < 20; j++){
                  if(t.x[j][q] == 17 || t.x[j][q] == 19){
                    t.x[j][q] = 0;
                    t.x[j][q - 1] = 0;
                  }
                  else{
                    break;
                  }
                }
                for(j = t.I[i][2]; j < 20; j++){
                  if(t.x[j][q] == 17 || t.x[j][q] == 19){
                    t.x[j][q] = 0;
                    t.x[j][q - 1] = 0;
                  }
                  else{
                    break;
                  }
                }
                t.x[t.I[i][4]][t.I[i][3]] = 0;
                delete t.I[i];
              }
            }
          }
          
          // Reorganize remaining pipes
          t.ab = t.I;
          t.I = [];
          for(i in t.ab){
            if(t.ab[i]){
              t.I.push(t.ab[i]);
            }
          }
        }
        
        // Erase balances if we click on tile #15
        if(w == 0){
          if(t.x[r][q] == 15){
            for(i in t.J){
              if(
                (
                  t.J[i][1] == r
                  &&
                  (
                    t.J[i][0] == q
                    ||
                    t.J[i][0] == q - 1
                    ||
                    t.J[i][0] == q + 1
                  )
                )
                ||
                (
                  t.J[i][3] == r
                  &&
                  (
                    t.J[i][2] == q
                    ||
                    t.J[i][2] == q - 1
                    ||
                    t.J[i][2] == q + 1
                  )
                )
              ){
                t.x[t.J[i][1]][t.J[i][0]] = 0;
                t.x[t.J[i][1]][t.J[i][0] - 1] = 0;
                t.x[t.J[i][1]][t.J[i][0] + 1] = 0;
                
                t.x[t.J[i][3]][t.J[i][2]] = 0;
                t.x[t.J[i][3]][t.J[i][2] - 1] = 0;
                t.x[t.J[i][3]][t.J[i][2] + 1] = 0;
                
                delete t.J[i];
              }
            }
          }
          
          // Reorganize remaining balances
          t.ab = t.J;
          t.J = [];
          for(i in t.ab){
            if(t.ab[i]){
              t.J.push(t.ab[i]);
            }
          }
        }
      }
      
      // Left click
      else{
        
        // Special cases
        // Tile #1: allow only one time machine, below line 1
        if(A == 1){
          
          // If the two tiles are writable
          if(r > 0 && AF(q, r) && AF(q, r - 1)){
            for(j in t.x){
              for(i in t.x[j]){
                if(t.x[j][i] == 22 || t.x[j][i] == 23){
                  t.x[j][i] = 0;
                }
              }
            }
            t.x[r - 1][q] = 22;
            t.x[r][q] = 23;
          }
        }
        
        // Tile #2: only one flag
        else if(A == 2){
          
          // If the tile is writable
          if(AF(q, r)){
          
            for(j in t.x){
              for(i in t.x[j]){
                if(t.x[j][i] == 2){
                  t.x[j][i] = 0;
                }
              }
            }
            t.x[r][q] = 2;
          }
        }
        
        // Tile #14: pipe
        else if(A == 14){
          
          // If the two tiles are writable
          if(AF(q, r) && AF(q + 1, r)){
            
            // 1st click: set position 1 (x, y)
            if(pipe_click == 0){
              t.I[v] = [];
              t.I[v][0] = q;
              t.I[v][1] = r;
              t.x[r][q] = 16;
              t.x[r][q + 1] = 17;
              pipe_click ++;
            }
            
            // 2nd click: test if in-between tiles are writable and set position 2 (y)
            else if(pipe_click == 1){
              
              if(true){ // todo
                t.I[v][2] = r;
                t.x[r][t.I[v][0]] = 16;
                t.x[r][t.I[v][0] + 1] = 17;
                pipe_click ++;
              }
            }
            
            // 3rd click: set switch position (x, y)
            else if(pipe_click == 2){
              t.I[v][3] = q;
              t.I[v][4] = r;
              t.x[r][q] = 20;
              v++;
              pipe_click = 0;
            }
          }
        }
        
        // Tile #15: balanced platforms
        else if(A == 15){
          
          // If the three tiles are writable
          if(AF(q - 1, r) && AF(q, r) && AF(q + 1, r)){
            
            // 1st click: platform 1 (x, y)
            if(w == 0){
              t.J[z] = [];
              t.J[z][0] = q;
              t.J[z][1] = r;
              w++
            }
            
            // 2nd click: set position 2 (x, y)
            else if(w == 1){
              t.J[z][2] = q;
              t.J[z][3] = r;
              z++;
              w = 0;
            }
            
            t.x[r][q - 1] = 15;
            t.x[r][q] = 15;
            t.x[r][q + 1] = 15;
          }
        }
        
        // Normal case: save current tile
        else if(AF(q, r)){
          t.x[r][q] = A;
        }      
      }
      
      // Map has been updated, redraw everything
      AP(1);
    }
    c.closePath();
  }
}

// Keyboard input (during gameplay)
onkeydown = (e,f,g) => {
  if(d == 2){
    
    // Top
    if(e.keyCode == 38 || e.keyCode == 90 || e.keyCode == 87){
      if(O.n){
        O.m = true;
        O.n = false;
        aa = true;
      }
    }
    
    // Right
    if(e.keyCode == 39 || e.keyCode == 68){
      O.E = true;
      ac = true;
    }
    
    // Left
    if(e.keyCode == 37 || e.keyCode == 65 ||e.keyCode == 81){
      O.D = true;
      ab = true;
    }
  }
}

onkeyup = (e,f,g) => {
  
  // During gameplay
  if(d == 2){
    
    // Top
    if(e.keyCode == 38 || e.keyCode == 90 || e.keyCode == 87){
      O.m = false;
      O.n = true;
      aa = false;
    }
    
    // Right
    if(e.keyCode == 39 || e.keyCode == 68){
      O.E = false;
      ac = false;
    }
    
    // Left
    if(e.keyCode == 37 || e.keyCode == 65 || e.keyCode == 81){
      O.D = false;
      ab = false;
    }
    
    // R (reset)
    if(e.keyCode == 82){
      AH();
      _ = 0;
    }
    
    // Space (press to toggle between pick cube and drop cube)
    if(e.keyCode == 32){
      O.r[N] = true;
    }
    
    // Shift 
    if(e.keyCode == 16){
      O.F[N] = true;
    }
  }
}

// Rendering
// =========

mute = false;

// Draw current screen (on load, when AP is called, and when the hash changes)
// If e is set, update the level editor without loading the map from the hash
AP = onload = onhashchange = (e, f, g) => {
  
  // Reset canvas
  a.width ^= 0;
  
  // Global text settings
  c.font = "bold 30px arial";
  c.textAlign = "center";
  
  // Pixelize graphics
  c["mozImageSmoothingEnabled"] = false;
  c["imageSmoothingEnabled"] = false;
  
  // Main menu
  // =========

  if(d == 0){
    
    // Cursor
    a.style.cursor = "pointer";
    
    // Background
    t = {hash:"0000==0000000000000000000000000000000000000====0000000000000000000000000000000000000000000000000000000000000000===000000000000000000000000000000000000=====00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000900000000000000059595000000000000000000000000000000000000000000000@A00000000000000000000000000000000000000BC00J00000000000000000000000000000000000BC03333333333333333333333333333333333333333",I:[[35,15,17,40,17]],J:[]};

    ae = [,];
    AJ();
    AK();
    
 
    // Show title
    c.drawImage(b, 512, 0, 70, 16, 120, 150, 280, 64);
    c.drawImage(b, 583, 0, 270, 16, 120, 250, 1080, 64);

    // Draw buttons
    c.fillStyle = "#000";
    c.beginPath();
    c.fillRect(500, 400, 100, 80);
    c.fillRect(650, 400, 100, 80);
    c.fillStyle = "#fff";
    c.fillText("MAKE", 700, 450);
    c.fillText("PLAY", 550, 450);
    
    c.fillText((mute ? "🔊" : "🔇"), 1250, 40);
    c.stroke();
    c.closePath();
  }
  
  // Level selection menu
  if(d == 1){
    
    // Cursor
    a.style.cursor = "pointer";
    
    c.beginPath();
    c.fillStyle = "#000";
    c.fillRect(590, 520, 100, 80);
    k = 0;
    for(i = 0; i < 10; i++){
      for(j = 0; j < 3; j++){
        l = j * 10 + i + 1;
        c.fillStyle = "#000";
        c.fillRect(i * 120 + 50, j * 100 + 120, 100, 80);
        c.fillStyle = "#fff";
        c.fillText(+localStorage["scpm"] >= l ? l : "?", i * 120 + 100, j * 100 + 170);
        if(localStorage["scpm" + l] <= levels[l].ac){
          c.fillText("🏅", i * 120 + 135, j * 100 + 145);
        }
        k += (+localStorage["scpm" + l] || 0);
      }
    }
    
    if(+localStorage["scpm"] >= 30){
      c.fillStyle = "#000";
      c.fillRect(50, 420, 100, 80);
      c.fillStyle = "#fff";
      c.fillText(+localStorage["scpm"] >= 31 ? 31 : "?", 100, 470);
      if(localStorage["scpm" + l] <= levels[l].ac){
        c.fillText("🏅", 135, 445);
      }
    }
    
    c.fillText("◀", 40, 70);
    
    c.fillStyle = "#000";
    c.fillText("JS13K LEVELS", 642, 72);
    c.fillText("TWITTER LEVELS", 642, 472);
    c.fillStyle = "#fff";
    c.fillText("JS13K LEVELS", 640, 70);
    c.fillText("TWITTER LEVELS", 640, 470);
    c.fillText("GO", 640, 570);
    c.fillStyle = "#000";
    if(k){
      c.fillText("Total time: " + ~~((k / 30) / 60) + ":" + ("0" + ((k / 30) % 60).toFixed(2)).slice(-5), 1100, 450);
    }
    c.stroke();
    c.closePath();
  }
  
  // Playing
  if(d == 2){
    
    // Cursor
    a.style.cursor = "crosshair";
    
    if(ad){
      clearInterval(ad);
    }
    AH();
    ad = setInterval(
    
    // Game ad
    // =========
    
    () => {

      // Reset canvas
      a.width ^= 0;
      
      // Draw exit button
      c.font = "bold 30px arial";
      c.fillStyle = "#000";
      c.fillText("×", 1255, 25);
      
      // First levels: add text
      if(n == 1){
        c.font = "bold 30px arial";
        c.textAlign = "center";
        c.lineJoin = "round";
        c.fillStyle = "#000";
        c.fillText(t.txt || "", 642, 82);
        c.fillText(t.txt2 || "", 642, 122);
        c.fillStyle = "#fff";
        c.fillText(t.txt || "", 640, 80);
        c.fillText(t.txt2 || "", 640, 120);
      }
      
      // Save keys being L (for latest Z only)
      if(O.D){
        O.j[N] = true;
      }
      if(O.E){
        O.g[N] = true;
      }
      if(O.m){
        O.l[N] = true;
      }
      
      // Pixelize graphics
      c.mozImageSmoothingEnabled = false;
      c.imageSmoothingEnabled = false;
      
      // On first N:
      // ---------------
      if(N == 0){
        
        // Init states of pipes, cubes, balances...
        AJ();
      }
      
      // Then, at each N:
      // --------------------
      
      // Move and draw pipes
      // For each pipe
      for(var i in t.I){
        
        // Go to position 2 when switch is L
        if(V[i].L){
          af = t.I[i][2] * 32;
        }
        
        // Go to position 1 when switch is not L
        else {
          af = t.I[i][1] * 32;
        }
          
        // Go up
        if(V[i].y > af){
          V[i].y = Math.max(V[i].y - 4, af);
        }
        
        // Go down
        else if(V[i].y < af){
          V[i].y = Math.min(V[i].y + 4, af);
        }

        // Draw pipe body (tiles #18 / #19)
        D = false;
        for(var k = ~~(V[i].y / 32) + 1; k < 21; k++){
          if(k < 20 && !AE(AC(t.I[i][0] * 32, k * 32)) && !AE(AC(t.I[i][0] * 32 + 1 * 32, k * 32)) && !D){
            AA(18, t.I[i][0], k);
            AA(19, t.I[i][0] + 1, k);
          }
          else{
            D = true;
            V[i].W = k * 32;
            break;
          }
        }
        
        // Draw pipe top (tiles #16 / #17)
        AB(16, t.I[i][0] * 32, V[i].y + 40);
        AB(17, t.I[i][0] * 32 + 32, V[i].y + 40);
        
        // Draw switch
        if(t.I[i][4]){
          
          if(V[i].L){
            AA(21, t.I[i][3], t.I[i][4]);
          }
          else{
            AA(20, t.I[i][3], t.I[i][4]);
          }
        }
      }
      
      // Draw map
      AK();
      
      // Reset all mechanisms:
      
      // Reset yellow buttons
      R = false;
      for(j = 0; j < 20; j++){
        for(i = 0; i < 40; i++){
          if(t.x[j][i] == 25){
            t.x[j][i] = 11;
          }
        }
      }
      
      // Reset green buttons
      for(i in t.I){
        V[i].L = false;
      }
      
      O.R = 1;
      
      for(i in t.u){
        t.u[i].R = 1;
      }
      
      for(i in t.J){
        W[i].M = 0;
        W[i].N = 0;
      }
      
      // Replay previous ae inputs
      for(Z in ae){
        AM(ae[Z], 1);
      }
      
      if(ae.length){
        Z = -1;
      }
      else{
        Z = 0;
      }
      
      // Play current Z
      AM(O);
      
      // Move and draw cubes
      for(i in t.u){
        
        // If cube is not in a #4 Q tile, assume it's not in a portal anymore
        if(
          AC(t.u[i].x + 1, t.u[i].y + 1) != 4
          &&
          AC(t.u[i].x + 32 - 1, t.u[i].y + 1) != 4
          &&
          AC(t.u[i].x + 1, t.u[i].y + 31) != 4
          &&
          AC(t.u[i].x + 32 - 1, t.u[i].y + 31) != 4
        ){
          t.u[i].k = false;
        }
        
        // Decrement Uation idle delay
        if(t.u[i].c){
          t.u[i].c--;
        }  
        
        // Apply gravity and collsions if the cube is not held
        if(t.u[i].Z === null){
          if(!t.u[i].c && !AE(AC(t.u[i].x, t.u[i].y + 31)) && !AE(AC(t.u[i].x + 31, t.u[i].y + 31))){
            if(t.u[i].e > 1){
              t.u[i].e -= 1;
            }
            else if(t.u[i].e < -1){
              t.u[i].e += 1;
            }
            else{
              t.u[i].e = 0;
            }
          }
          AL(t.u[i], 32, 1);
        }

        // Draw cube
        c.drawImage(b, 12 * 16, 0, 16, 16, t.u[i].x, 40 + t.u[i].y, 32, 32);
      }
        
      // Draw previous ae
      for(Z in ae){
        AN(ae[Z], 1);
      }
      
      // Draw current Z
      AN(O);
      
      // Draw tiles that have ag, and ag in foreground
      for(i in j = {"blue": X, "orange": Y }){
        AA(4, j[i].q, j[i].r);
      }
        
      for(i in j = {"blue": X, "orange": Y }){

        c.fillStyle = i;
        
        if(j[i].T == 0){
          c.fillRect(j[i].q * 32, j[i].r * 32 + 40 - 8, 32, 8);
        }
        if(j[i].T == 1){
          c.fillRect(j[i].q * 32 + 28, j[i].r * 32 + 40, 8, 32);
        }
        if(j[i].T == 2){
          c.fillRect(j[i].q * 32, j[i].r * 32 + 40 + 28, 32, 8);
        }
        if(j[i].T == 3){
          c.fillRect(j[i].q * 32 - 4, j[i].r * 32 + 40, 8, 32);
        }
      }
      
      // Update mechanisms (yellow toggles / balances):
      // Apply yellow toggle (invert plain and transparent tiles if yellow toggle has changed during this N)
      if(R != U){
        mkaudio(SNDswitch0).play();
        for(j = 0; j < 20; j++){
          for(i = 0; i < 40; i++){
            if(t.x[j][i] == 9){
              t.x[j][i] = 10;
            }
            else if(t.x[j][i] == 10){
              t.x[j][i] = 9;
            }
          }
        }
      }
      
      // Save yellow toggle state 
      U = R;
      
      // Balances
      for(i in t.J){
        
        // More R on T 1 and no Q tile under platform 1 and no Q tile over platform 2
        if(
          W[i].M > W[i].N
          && !AE(AC(t.J[i][0] * 32 - 32, W[i].O + 20))
          && !AE(AC(t.J[i][0] * 32, W[i].O + 20))
          && !AE(AC(t.J[i][0] * 32 + 32, W[i].O + 20))
          && !AE(AC(t.J[i][2] * 32 - 32, W[i].P - 4))
          && !AE(AC(t.J[i][2] * 32, W[i].P - 4))
          && !AE(AC(t.J[i][2] * 32 + 32, W[i].P - 4))
        ){
          W[i].O += 4;
          W[i].P -= 4;
        }
        
        // More R on T 2 and no Q tile under platform 2 and no Q tile over platform 1
        else if(
          W[i].N > W[i].M
          && !AE(AC(t.J[i][2] * 32 - 32, W[i].P + 20))
          && !AE(AC(t.J[i][2] * 32, W[i].P + 20))
          && !AE(AC(t.J[i][2] * 32 + 32, W[i].P + 20))
          && !AE(AC(t.J[i][0] * 32 - 32, W[i].O - 4))
          && !AE(AC(t.J[i][0] * 32, W[i].O - 4))
          && !AE(AC(t.J[i][0] * 32 + 32, W[i].O - 4))
        ){
          W[i].O -= 4;
          W[i].P += 4;
        }
        
        // Draw line
        c.beginPath();
        c.strokeStyle = "#fff";
        c.lineWidth = 2;
        c.moveTo(t.J[i][0] * 32 + 16, W[i].O + 40 + 8);
        c.lineTo(t.J[i][2] * 32 + 16, W[i].P + 40 + 8);
        c.stroke();
        c.closePath();
        
        // Draw balance 1
        AB(15, t.J[i][0] * 32 - 32, W[i].O + 40);
        AB(15, t.J[i][0] * 32, W[i].O + 40);
        AB(15, t.J[i][0] * 32 + 32, W[i].O + 40);
        
        // Draw balance 2
        AB(15, t.J[i][2] * 32 - 32, W[i].P + 40);
        AB(15, t.J[i][2] * 32, W[i].P + 40);
        AB(15, t.J[i][2] * 32 + 32, W[i].P + 40);
      }
      
      // Next N
      N++;
      
      // Chrono
      if(!I){
        _++;
      }
      
      // Victoty animation (if we won) / Game over animation (if we lose)
      c.font = "bold 100px arial";
      c.fillStyle = "#000";
      c.textAlign = "center";
      
      // I
      if(I){
        J++;
        c.fillText("CLEARED!", 640, 300);
        c.font = "bold 30px arial";
        if(n == 1){
          c.fillRect(450, 350, 400, 130);
          c.fillStyle = "#fff";
          document.title = _;
          c.fillText("Time: " + (_ / 30).toFixed(2) + "s", 640, 400);
          c.fillText("Dev record: " + (t.ac / 30).toFixed(2) + "s", 640, 450);
          if(localStorage["scpm" + s]){
            localStorage["scpm" + s] = Math.min(+localStorage["scpm" + s], _);
          }
          else{
            localStorage["scpm" + s] = _;
          }
        }
      }
      
      // Current Z dies
      if(O.a == 3){
        K++;
        
        c.fillText("LOST!", 640, 350);
      }
      
      for(Z in ae){

        // Past Z dies or gets stuck (not at the time machine at the end of his N record)
        if(ae[Z].a == 3 || (ae[Z].p < N && !ae[Z].q && !I)){
          L++;
          c.fillText("PARADOX!", 640, 350);
        }
      }
      
      if(J == 1){
        mkaudio(SNDI0).play();
      }
      
      if(K == 1){
        mkaudio(SNDdie0).play();
      }
      
      if(L == 1){
        mkaudio(SNDglitch1).play();
      }
      
      if(K >= 30){
        a.width ^= 0;
        clearInterval(ad);
        d = n;
        t.K = true;
        a.width ^= 0;
        AP();
      }
      
      // Paradox (glitch)
      if(L){
        for(m = ~~(L / 5); m--;){
          c.drawImage(a, i = Math.random() * 1280, j = Math.random() * 648, k = Math.random() * 1280, l = Math.random() * 648, i + Math.random() * 100 - 50, j + Math.random() * 100 - 50, k, l);
        }
      }
      
      if(J >= 90){
        _ = 0;
        if(n == 1){
          s++;
          localStorage["scpm"] = Math.max(+localStorage["scpm"], s);
        }
        a.width ^= 0;
        clearInterval(ad);
        d = n;
        t.K = true;
        a.width ^= 0;
        AP();
      }
      
      if(K >= 30 || L >= 60){
        a.width ^= 0;
        clearInterval(ad);
        d = n;
        t.K = false;
        a.width ^= 0;
        AP();
      }
    }
    , 33);
  }
  
  // Level editor
  if(d == 3){
    
    // Cursor
    a.style.cursor = "pointer";
    
    c.strokeStyle = "#777";
    c.lineWidth = 1;
    
    // White BG (all screen)
    c.fillStyle = "#fff";
    c.fillRect(0, 0, 1280, 648);
    
    // Blue BG (tileset, grid)
    c.fillStyle = "#5C94FC";
    c.fillRect(0, 40, 1280, 640);
    
    c.beginPath();
    
    // Tileset
    for(i = 0; i < 16; i++){
      c.fillRect(8 + i * 35, 3, 32, 32);      
      c.rect(8 + i * 35, 3, 32, 32);
      AB(i, 8 + i * 35, 3);
    }
    
    c.stroke();
    c.closePath();
    
    // Tiles on grid
    if(!e){
      if(t.hash){
        t.x = [];
        for(var j = 0; j < 20; j++){
          t.x[j] = [];
          for(var i = 0; i < 40; i++){
            t.x[j][i] = t.hash.charCodeAt(j * 40 + i) - 0x30;
          }
        }
      }
    }
  
    for(j = 0; j < t.x.length; j++){
      for(i = 0; i < t.x[j].length; i++){
        F = t.x[j][i];
        AA(F, i, j);
        
        // Special cases
        
        // Tile #2: draw flag pole
        if(F == 2){
          E = false;
          if(j < 20){
            for(k = j + 1; k < 20; k++){
              if(!t.x[k][i] && !E){
                AA(24, i, k);
              }
              else{
                E = true;
              }
            }
          }
        }
      }
    }
    
    // Pipes
    for(i in t.I){
      
      C = t.I[i][1];
      
      // If the two positions of the pipe were placed
      if(t.I[i][2]){
        
        // Pipe body between low ang high (we save it in the map to avoid overwrite)
        B = t.I[i][1] < t.I[i][2] ? t.I[i][1] : t.I[i][2];
        C = t.I[i][1] < t.I[i][2] ? t.I[i][2] : t.I[i][1];
        for(k = B + 1; k < C; k++){
          AA(18, t.I[i][0], k);
          AA(19, t.I[i][0] + 1, k);
          t.x[k][t.I[i][0]] = 18;
          t.x[k][t.I[i][0] + 1] = 19;
        }
      }
      
      // If the first position of the pipe was placed
      if(t.I[i][1]){
        
        // Pipe body below low position (can be overwritten)
        D = false;
        for(k = C + 1; k < 21; k++){
          if(k < 20 && !t.x[k][t.I[i][0]] && !t.x[k][t.I[i][0] + 1] && !D){
            AA(18, t.I[i][0], k);
            AA(19, t.I[i][0] + 1, k);
          }
          else{
            D = true;
          }
        }
      }
      
      // Pipe position 1
      if(t.I[i][1]){
        AA(16, t.I[i][0], t.I[i][1]);
        AA(17, t.I[i][0] + 1, t.I[i][1]);
        t.x[t.I[i][1]][t.I[i][0]] = 16;
        t.x[t.I[i][1]][t.I[i][0] + 1] = 17;
        
      }
      
      // Pipe position 2
      if(t.I[i][2]){
        AA(16, t.I[i][0], t.I[i][2]);
        AA(17, t.I[i][0] + 1, t.I[i][2]);
        t.x[t.I[i][2]][t.I[i][0]] = 16;
        t.x[t.I[i][2]][t.I[i][0] + 1] = 17;
      }
      
      // Switch
      if(t.I[i][4]){
        AA(20, t.I[i][3], t.I[i][4]);
      }
    }
    
    // Balances
    for(i in t.J){
      
      // Draw line and balance 2
      if(t.J[i][3]){
        
        // Draw line
        c.beginPath();
        c.strokeStyle = "#fff";
        c.lineWidth = 2;
        c.moveTo(t.J[i][0] * 32 + 16, t.J[i][1] * 32 + 40 + 8);
        c.lineTo(t.J[i][2] * 32 + 16, t.J[i][3] * 32 + 40 + 8);
        c.stroke();
        c.closePath();
      
        // Balance 2
        AA(15, t.J[i][2] - 1, t.J[i][3]);
        AA(15, t.J[i][2], t.J[i][3]);
        AA(15, t.J[i][2] + 1, t.J[i][3]);
        
        t.x[t.J[i][3]][t.J[i][2] - 1] = 15;
        t.x[t.J[i][3]][t.J[i][2]] = 15;
        t.x[t.J[i][3]][t.J[i][2] + 1] = 15;
      }
      
      // Draw balance 1
      if(t.J[i][1]){
        AA(15, t.J[i][0] - 1, t.J[i][1]);
        AA(15, t.J[i][0], t.J[i][1]);
        AA(15, t.J[i][0] + 1, t.J[i][1]);
        
        t.x[t.J[i][1]][t.J[i][0] - 1] = 15;
        t.x[t.J[i][1]][t.J[i][0]] = 15;
        t.x[t.J[i][1]][t.J[i][0] + 1] = 15;
      }
    }
    
    
    // Show the tile being placed:
    if(r >= 0 && !p){
      
      // Special cases:
      // Tile #1: time machine
      if(A == 1){
        if(r > 0){
          AA(22, q, r - 1);
          AA(23, q, r);
        }
      }
      
      // Tile #14: pipe
      else if(A == 14){
        if(pipe_click == 0){
          AA(16, q, r);
          AA(17, q + 1, r);
        }
        if(pipe_click == 1){
          AA(16, t.I[v][0], r);
          AA(17, t.I[v][0] + 1, r);
        }
        if(pipe_click == 2){
          AA(20, q, r);
        }
      }
      
      // Tile #15: balance
      else if(A == 15){
        AA(15, q - 1, r);
        AA(15, q, r);
        AA(15, q + 1, r);
      }
      
      // Normal case:
      else {
        AA(A, q, r);
      }
    }
    
    // Grid
    c.beginPath();
    c.strokeStyle = "#777";
    c.lineWidth = 1;
    for(i = 0; i < 40; i++){
      c.moveTo(i * 32, 40);
      c.lineTo(i * 32, 648);
    }
    for(j = 0; j < 20; j++){
      c.moveTo(0, 40 + j * 32);
      c.lineTo(1280, 40 + j * 32);
    }
    
    // Buttons
    c.fillStyle = "#000";
    c.fillRect(750, 4, 100, 32);
    c.fillRect(875, 4, 100, 32);
    c.fillRect(1000, 4, 100, 32);
    c.fillRect(1125, 4, 100, 32);
    c.fillStyle = "#fff";
    c.font = "bold 20px arial";
    c.fillText("TEST", 800, 28);
    c.fillText("SHARE", 925, 28);
    c.fillText("CLEAR", 1050, 28);
    c.fillText("EXIT", 1175, 28);
    c.stroke();
    c.closePath();
    
    // Current tile on the tileset
    c.beginPath();
    i = A;
    c.strokeStyle = "red";
    c.lineWidth = 3;
    c.rect(8 + i * 35, 3.5, 32, 32);
    c.stroke();
    c.closePath();
  }
}

// Hash (G levels)
// ====================

// If a hash is set, play the level directly
onhashchange = (e,f,g) => {
  if(location.hash){
    t = JSON.parse(decodeURIComponent(location.hash.slice(1)));
    d = 2;
    AP();
  }
}

onhashchange();

// Sounds by Anders Kaare
// ======================

mkaudio = (fn) => {
	var data = [];
	for (var i = 0;;i++) {
		var smp = fn(i);
		if (smp===null) break;
		data.push(smp);
	}
	var l = data.length;
	var l2=l*2;

	var b32 = v => {
		var s = 0;
		var b = "";
		for (var i=0; i<4; i++,s+=8) b+=String.fromCharCode((v>>s)&255);
		return b;
	};
	var b16 = (v) => {
		var b = b32(v);
		return b[0]+b[1];
	};

	var SR=48e3;
	var b = "RIFF"+b32(l2+36)+"WAVEfmt "+b32(16)+b16(1)+b16(1)+b32(SR)+b32(SR*2)+b16(2)+b16(16)+"data"+b32(l2);
	for (var i in data) b+=b16(data[i]*10e3);
	return new Audio("data:audio/wav;base64,"+btoa(b));
}

P=Math.pow;
S=Math.sin;

T = (i,n) => {
	return (n-i)/n;
}

SNDjump2 = (i) => {
	i=i*1.5;
	var n = 2e4;
	if (i>n) return null;
	return ((P(i,1.075)&128)?1:-1)*P(T(i,n),2);
}

SNDdie0 = (i) => {
	var n=5e4;
	if (i > n) return null;
	return ((P(i,0.9)&200)?1:-1)*P(T(i,n),3);
}

SNDbrick1 = (i) => {
	var n=5e3;
	if (i > n) return null;
	return ((P(i+S(i*0.01)*1000,0.8)&200)?0.5:-0.5)*P(T(i,n),1);
}

SNDglitch1 = (i) => {
	var n=9e4;
	if (i > n) return null;
	return ((P(i+S(i*0.01)*1000,0.8)&200)?0.5:-0.5)*P(T(i,n),1);
}

SNDcoin1 = (i) => {
	var n=1.6e4;
	var c=n/7;
	if (i > n) return null;
	var q=P(T(i,n),2.1);
	return (i<c ? ((i+S(-i/900)*10)&16) : i&13) ?q:-q;
}

SNDI0 = (i) => {
	var notes = [0,4,7,12,undefined,7,12];
	var n=4e4;
	if (i > n) return null;
	var idx = ((notes.length*i)/n)|0;
	var note = notes[idx];
	if (note === undefined) return 0;
	var r = P(2,note/12)*0.8;
	var q = T((i*notes.length)%n,n);
	return ((i*r)&64)?q:-q
}

SNDswitch0 = (i) => {
	var n=7e3;
	if (i > n) return null;
	return ((((i^(i>>3))^(i*i*7.3)^(i<<4))&65535)/65536)*T(i,n);
}

SNDtimetravel0 = (i) => {
	var n=5e4;
	var n1=1e5;
	if (i > n) return null;
	i=P(i,1.2-S(i/n1))*7;
	var x=S(i/30+S(i/1500));
	return P(x,9)*T(i,n);
}

SNDshoot1 = (i) => {
	var n=6e3;
	if (i > n) return null;
	var q = T(i,n);
	return (P(i*50,0.7)&33)?q:-q;
}

SNDwhatportal2 = (i) => {
	var n=1e4;
	if (i > n) return null;
	var q = T(i,n);
	return S(i/55*S(i/99)+S(i/100))*q;
}

SNDwhat0 = (i) => {
	var n=1e4;
	if (i > n) return null;
	var q = T(i,n);
	return S(i*0.01*S(i*0.4)+S(i/100));
}


// Music by Anders Kaare
// http://veralin.dk/2k.html
Music = () => {

  MM=new (function(){
    if (!window.AudioContext) return;

    var M=this;

    var ctx=new AudioContext;
    var node=ctx.createScriptProcessor(4096,0,1);

    // "constants"
    var RATE=ctx.sampleRate/48e3;
    var POW=Math.pow;
    var SIN=Math.sin;
    var RND=Math.random;
    var NSIN=function(x){return SIN(x)+RND()*0.6};
    var P2=Math.PI*2;
    //var PRB=function(x){return RND()<x;};
    var OSC=function(fn){
      var x=0;
      return function(note) {
        x+=POW(2,note/12)*RATE;
        if(x>P2)x-=P2;
        return fn(x);
      };
    };

    // oscillators
    var snare=OSC(NSIN);
    var pling=OSC(function(x) {
      return (x/P2-0.5);
    });
    var pling2=OSC(function(x) {
      return (x/P2-0.5);
    });
    var bass=OSC(function (x) {
      return (x/P2-0.5)+POW(SIN(x),5)*3;
    });

    var pos=1;
    var step=-1;
    var vibrato=0;

    node.onaudioprocess = function(e) {
      var data = e.outputBuffer.getChannelData(0);
      for (var i=0;i<data.length;i++) {
        pos+=M.t/RATE;
        vibrato+=0.001/RATE;
        if(pos>=1){
          pos-=1;
          step++;
        }
        var decay=1-pos;

        var o=0;

        var X=null;
        var bt=0;

        var lseq,lseq2;
        if ((step%128)<64) {
          lseq = [3,4,4,4,3,4,0,-3,0,X,X,0,X,X,0,X,3,4,4,4,3,4,0,-3,0,12,X,12,12,X,X,X];
          lseq2 = [X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,-1,0,0,0,-1,0,-5,-8,-5,X,X,-5,X,X,-5,X,X];
        } else {
          lseq = [6,7,7,7,6,5,4,2,-5,X,X,7,X,X,X];
          lseq2 = [X,X,X,X,-10,-5,X,X,X,-10];
          bt = -5;
        }

        var L=lseq.length;
        var ln = lseq[step%L];
        if (ln!=X) o+=pling(-81+ln+24)*decay*M.p;

        L=lseq2.length;
        var ln = lseq2[step%L];
        if (ln!=X) o+=pling2(-81+ln+24+SIN(vibrato)*0.05)*decay*M.p;

        var bseq=[0,X,X,0,7,9,X,7];
        L=bseq.length;
        var bseq2=[X,12,X,12,12,X,12,X];
        var bn = (((step/L)&3)<3?bseq:bseq2)[step%L];
        if (bn!=X) o+=bass(-81+bn+bt-SIN(vibrato)*0.05)*M.b*decay;

        var drumx=((1-pos)+(step&1))/2;
        if ((step&2)==2) o += snare(-70+POW(drumx,15)*60)*M.s*decay*RND();


        data[i]=o;
      }
    };
    node.connect(ctx.destination);

    // hi xem, this is the interface:
    M.stop = function() { node.disconnect(); } // XXX you can remove this to conserve space

    M.s = 0.1; // snare volume
    M.p = 0.2; // pling volume
    M.b = 0.2; // bass volume
    M.t=1.1e-4; // tempo
  })

}

Music();
</script>